<template>
  <div class="workflow-runtime-list">
    <!-- 内容区域：运行历史列表 -->
    <main ref="mainContainer" class="runtime-scroll-container" :style="{ height: mainHeight }">
      <div ref="scrollContainer" class="runtime-scroll-inner" @scroll="handleScroll">
        <div v-if="!runtimeList.length" class="empty-state">
          <i class="el-icon-finished" />
          <p>暂无运行记录</p>
          <p class="hint">点击下方"运行"按钮开始执行工作流</p>
        </div>

        <div v-else class="runtime-list">
          <div v-for="runtime in runtimeList" :key="runtime.runtimeUuid" class="runtime-item">
            <!-- 用户输入消息 -->
            <div class="message-row user-message-row">
              <div class="message-wrapper user-message">
                <div class="message-header">
                  <div class="message-info">
                    <span class="message-label">用户输入</span>
                    <span class="message-time">{{ formatTime(runtime.cTime || runtime.CTime) }}</span>
                  </div>
                  <el-button
                    type="text"
                    size="small"
                    icon="el-icon-delete"
                    class="delete-btn"
                    @click="handleDelete(runtime.runtimeUuid)"
                  >
                    删除
                  </el-button>
                </div>
                <div class="message-content">
                  <div v-if="runtime.input && Object.keys(runtime.input).length" class="input-content">
                    <div v-for="(value, key) in runtime.input" :key="key" class="input-item">
                      <span class="input-label">{{ key }}:</span>
                      <span class="input-value">{{ formatValue(value) }}</span>
                    </div>
                  </div>
                  <div v-else class="no-input">
                    <span>无输入</span>
                  </div>
                </div>
              </div>
              <div class="message-avatar">
                <el-avatar :size="36" icon="el-icon-user" />
              </div>
            </div>

            <!-- AI 输出消息 -->
            <div class="message-row ai-message-row">
              <div class="message-avatar">
                <el-avatar :size="36" class="ai-avatar">
                  <i class="el-icon-s-operation" />
                </el-avatar>
              </div>
              <div class="message-wrapper ai-message">
                <div class="message-header">
                  <div class="message-info">
                    <span class="message-label">工作流输出</span>
                    <el-tag :type="getStatusType(runtime.status)" size="mini">
                      {{ getStatusText(runtime.status) }}
                    </el-tag>
                  </div>
                  <el-button
                    v-if="!runtime.loading && runtime.status !== 1"
                    type="text"
                    size="small"
                    @click="showExecutionDetail(runtime)"
                  >
                    执行详情
                  </el-button>
                </div>
                <div class="message-content">
                  <!-- 失败状态 -->
                  <div v-if="runtime.status === 4" class="error-content">
                    <i class="el-icon-warning" />
                    <span>{{ runtime.status_remark || runtime.statusRemark || '工作流执行失败' }}</span>
                  </div>

                  <!-- 有输出内容（包括loading中的流式输出）：优先显示output -->
                  <div v-else-if="runtime.output && runtime.output.trim() !== ''" class="output-content">
                    <!-- loading时显示流式指示器在顶部 -->
                    <div v-if="runtime.loading" class="streaming-header">
                      <i class="el-icon-loading" />
                      <span>工作流执行中...</span>
                    </div>

                    <div class="output-text-wrapper">
                      <div v-if="typeof runtime.output === 'string'" class="output-text">
                        {{ runtime.output }}
                      </div>
                      <div v-else-if="typeof runtime.output === 'object'" class="output-object">
                        <div v-for="(value, key) in runtime.output" :key="key" class="output-item">
                          <span class="output-label">{{ key }}:</span>
                          <span class="output-value">{{ formatValue(value) }}</span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <!-- 运行中但还没有输出：loading=true 且 output为空 -->
                  <div v-else-if="runtime.loading" class="loading-content">
                    <i class="el-icon-loading" />
                    <span>工作流执行中...</span>
                  </div>

                  <!-- 其他状态：已完成但无输出 -->
                  <div v-else class="no-output">
                    <span>无输出</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- 加载更多提示 -->
        <div v-if="loading" class="loading-more">
          <i class="el-icon-loading" />
          <span>加载中...</span>
        </div>
        <div v-if="loadedAll && runtimeList.length" class="loaded-all">
          <span>已加载全部记录</span>
        </div>
      </div>
    </main>

    <!-- 底部：运行工作流区域 -->
    <footer ref="footerContainer" class="runtime-footer">
      <workflow-run-detail
        ref="runDetailRef"
        :workflow="workflow"
        @run="handleRunWorkflow"
      />
    </footer>

    <!-- 执行详情对话框 -->
    <el-dialog
      v-el-drag-dialog
      :visible.sync="detailDialogVisible"
      title="执行详情"
      :modal="true"
      width="800px"
      :close-on-click-modal="false"
      :close-on-press-escape="false"
      :show-close="true"
      :append-to-body="true"
      :modal-append-to-body="true"
      class="execution-detail-dialog"
      destroy-on-close
      top="5vh"
    >
      <div v-if="currentRuntimeDetail" class="execution-detail">
        <!-- 基本信息 -->
        <div class="detail-section">
          <h4>基本信息</h4>
          <el-descriptions :column="2" border size="small">
            <el-descriptions-item label="执行状态">
              <el-tag :type="getStatusType(currentRuntimeDetail.status)" size="mini">
                {{ getStatusText(currentRuntimeDetail.status) }}
              </el-tag>
            </el-descriptions-item>
            <el-descriptions-item label="执行时间">
              {{ formatTime(currentRuntimeDetail.cTime || currentRuntimeDetail.c_time) }}
            </el-descriptions-item>
            <el-descriptions-item v-if="currentRuntimeDetail.elapsedMs || currentRuntimeDetail.elapsed_ms" label="耗时">
              {{ currentRuntimeDetail.elapsedMs || currentRuntimeDetail.elapsed_ms }}ms
            </el-descriptions-item>
          </el-descriptions>
        </div>

        <!-- 节点执行详情 -->
        <div v-if="currentRuntimeDetail.nodes && currentRuntimeDetail.nodes.length" class="detail-section">
          <h4>节点执行详情</h4>
          <el-timeline>
            <el-timeline-item
              v-for="(node, index) in currentRuntimeDetail.nodes"
              :key="index"
              :type="getNodeStatusType(node.status)"
              :icon="getNodeStatusIcon(node.status)"
            >
              <div class="node-detail">
                <div class="node-header">
                  <span class="node-name">{{ node.name || node.componentName || node.component_name }}</span>
                  <el-tag :type="getStatusType(node.status)" size="mini">
                    {{ getStatusText(node.status) }}
                  </el-tag>
                </div>
                <div v-if="node.output" class="node-output">
                  <div class="output-label">输出:</div>
                  <div class="output-value">{{ formatValue(node.output) }}</div>
                </div>
                <div v-if="node.errorMsg || node.error_msg" class="node-error">
                  <i class="el-icon-warning" />
                  <span>{{ node.errorMsg || node.error_msg }}</span>
                </div>
              </div>
            </el-timeline-item>
          </el-timeline>
        </div>

        <!-- 错误信息 -->
        <div v-if="currentRuntimeDetail.status === 4" class="detail-section">
          <h4>错误信息</h4>
          <el-alert
            :title="currentRuntimeDetail.status_remark || currentRuntimeDetail.statusRemark || '工作流执行失败'"
            type="error"
            :closable="false"
          />
        </div>
      </div>
    </el-dialog>
  </div>
</template>

<script>
import { workflowRun, workflowRuntimeSearch, workflowRuntimeDelete } from '@/components/70_ai/api/workflowService'
import WorkflowRunDetail from './WorkflowRunDetail.vue'
import elDragDialog from '@/directive/el-drag-dialog'

export default {
  name: 'WorkflowRuntimeList',

  directives: { elDragDialog },

  components: {
    WorkflowRunDetail
  },

  props: {
    workflow: {
      type: Object,
      required: true
    }
  },

  data () {
    return {
      running: false,
      loading: false,
      loadedAll: false,
      currentPage: 1,
      pageSize: 20,
      detailDialogVisible: false,
      currentRuntimeDetail: null,
      mainHeight: 'auto',
      currentController: null, // 用于取消SSE连接
      scrollTimer: null, // 用于滚动防抖
      localRuntimeList: [] // 本地runtime列表，不使用Vuex
    }
  },

  computed: {
    // 明确表达"workflow 是否就绪可以加载数据"这个概念
    workflowReady () {
      return Boolean(this.workflow.id && this.workflow.workflowUuid)
    },

    runtimeList () {
      // 使用本地列表
      return this.localRuntimeList
    },

    canRun () {
      // 判断工作流是否可以运行
      if (!this.workflow.workflowUuid || !this.workflow.nodes || this.workflow.nodes.length < 2) {
        return false
      }

      const hasStart = this.workflow.nodes.some(n => n.wfComponent && n.wfComponent.name === 'Start')
      const hasEnd = this.workflow.nodes.some(n => n.wfComponent && n.wfComponent.name === 'End')

      return hasStart && hasEnd
    }
  },

  watch: {
    // 只需要一个 watch，监听 workflow 是否就绪
    workflowReady: {
      immediate: true,
      handler (isReady) {
        if (isReady) {
          this.loadRuntimeList()
        }
      }
    },

    // 监听运行时列表变化，自动滚动到底部
    runtimeList: {
      handler () {
        this.scrollToBottom()
      },
      deep: true
    }
  },

  mounted () {
    this.calculateMainHeight()
    // 监听窗口大小变化
    window.addEventListener('resize', this.calculateMainHeight)
  },

  updated () {
    this.$nextTick(() => {
      this.calculateMainHeight()
    })
  },

  beforeDestroy () {
    // 清理resize监听器
    window.removeEventListener('resize', this.calculateMainHeight)

    // 清理SSE连接
    if (this.currentController) {
      this.currentController.abort()
      this.currentController = null
    }

    // 清理滚动定时器
    if (this.scrollTimer) {
      clearTimeout(this.scrollTimer)
      this.scrollTimer = null
    }
  },

  methods: {

    async loadRuntimeList (loadMore = false) {
      // 防止重复加载（例如快速滚动）
      if (this.loading) {
        return
      }

      if (!loadMore) {
        this.currentPage = 1
        this.loadedAll = false
      }

      this.loading = true

      try {
        const response = await workflowRuntimeSearch({
          workflowId: this.workflow.id,
          currentPage: this.currentPage,
          pageSize: this.pageSize
        })

        const records = response.data.records || []

        // 转换并校验后端数据结构：将outputData/inputData展开为output/input
        const validRecords = []
        records.forEach(runtime => {
          // 【防御性校验】必须有runtimeUuid，否则跳过
          if (!runtime.runtimeUuid) {
            console.warn('⚠️ 跳过无效runtime（缺少runtimeUuid）:', runtime)
            return
          }

          // 处理input: 从inputData提取到input
          if (runtime.inputData && typeof runtime.inputData === 'object') {
            runtime.input = {}
            for (const [key, value] of Object.entries(runtime.inputData)) {
              runtime.input[key] = value
            }
          } else {
            // 如果没有inputData，设置空对象
            runtime.input = runtime.input || {}
          }

          // 处理output: 从outputData.output.value提取到output
          if (runtime.outputData && typeof runtime.outputData === 'object') {
            if (runtime.outputData.output && runtime.outputData.output.value) {
              runtime.output = runtime.outputData.output.value
            } else {
              // 兼容其他格式
              runtime.output = runtime.outputData
            }
          } else {
            // 如果没有outputData，设置空字符串
            runtime.output = runtime.output || ''
          }

          // 【防御性校验】通过所有检查的记录才添加到列表
          validRecords.push(runtime)
        })

        console.log(`✅ 有效记录: ${validRecords.length}/${records.length}`)

        // 【重要】后端返回的是倒序（最新在前），需要反转为正序（最老在前）
        const reversedRecords = validRecords.reverse()

        if (loadMore) {
          // 加载更多：追加到列表前面
          this.localRuntimeList = [...reversedRecords, ...this.localRuntimeList]
        } else {
          // 首次加载：直接设置
          this.localRuntimeList = reversedRecords
        }

        if (validRecords.length < this.pageSize) {
          this.loadedAll = true
        } else {
          this.currentPage++
        }
      } catch (error) {
        console.error('加载运行历史失败:', error)
        this.$message.error(error.message || '加载运行历史失败')
      } finally {
        this.loading = false
      }
    },

    handleScroll (event) {
      const { scrollTop, scrollHeight } = event.target

      // 滚动到顶部时加载更多
      if (scrollTop < 50 && !this.loading && !this.loadedAll) {
        const prevScrollHeight = scrollHeight
        this.loadRuntimeList(true).then(() => {
          this.$nextTick(() => {
            // 保持滚动位置
            event.target.scrollTop = event.target.scrollHeight - prevScrollHeight
          })
        })
      }
    },

    /**
     * 滚动到底部
     * 参考AI Chat的MessageList.vue和知识库Chat的RagChatDialog.vue
     */
    scrollToBottom () {
      // 清除之前的定时器
      if (this.scrollTimer) {
        clearTimeout(this.scrollTimer)
      }

      // 使用requestAnimationFrame确保DOM已更新
      this.scrollTimer = setTimeout(() => {
        this.$nextTick(() => {
          const scrollContainer = this.$refs.scrollContainer
          if (scrollContainer) {
            scrollContainer.scrollTo({
              top: scrollContainer.scrollHeight,
              behavior: 'smooth'
            })
          }
        })
      }, 50) // 50ms防抖
    },

    /**
     * 运行工作流
     * 参考aideepin: RunDetail.vue handleSubmit() (lines 122-202)
     * 对应后端: WorkflowController.run() 返回SSE流
     */
    handleRunWorkflow (inputs) {
      // 防止重复点击
      if (this.running || !this.canRun) {
        return
      }

      this.running = true

      // 构造输入数组（保持与后端List<JSONObject>格式一致）
      const inputList = inputs.map(item => ({
        name: item.name,
        content: item.content,
        required: item.required || false
      }))

      // 创建AbortController用于取消SSE连接
      const controller = new AbortController()
      this.currentController = controller

      // 用于累积工作流输出
      let accumulatedOutput = ''
      let currentRuntimeUuid = null

      // 使用回调函数处理SSE事件流
      workflowRun({
        wfUuid: this.workflow.workflowUuid,
        inputs: inputList,
        signal: controller.signal,

        // [START]事件回调：工作流启动
        startCallback: (wfRuntimeJson) => {
          if (!wfRuntimeJson) {
            this.$message.error('启动失败')
            this.running = false
            return
          }

          // 解析runtime对象
          const runtime = JSON.parse(wfRuntimeJson)

          // 保存runtime UUID用于后续更新
          currentRuntimeUuid = runtime.runtimeUuid

          // 将用户输入保存到runtime.input（用于聊天显示）
          runtime.input = {}
          inputs.forEach(item => {
            runtime.input[item.name] = item.content
          })

          // 初始化output为空字符串
          runtime.output = ''
          runtime.loading = true // 设置loading状态

          // 添加到本地列表（最新的在最后面，像微信聊天一样）
          this.localRuntimeList.push(runtime)

          // 成功提示
          this.$message.success('工作流已开始执行')

          // 滚动到底部（显示最新消息）
          this.$nextTick(() => {
            const container = this.$refs.scrollContainer
            if (container) {
              container.scrollTop = container.scrollHeight
            }
          })
        },

        // 节点事件回调：NODE_RUN_xxx, NODE_CHUNK_xxx, NODE_OUTPUT_xxx
        messageReceived: (chunk, eventName) => {
          console.log(`📨 [messageReceived] eventName: ${eventName}, chunk length: ${chunk ? chunk.length : 0}`)

          // 处理NODE_CHUNK事件：累积LLM流式输出
          if (eventName && eventName.startsWith('[NODE_CHUNK_')) {
            console.log(`📝 [NODE_CHUNK] 收到chunk: "${chunk}", 累积前长度: ${accumulatedOutput.length}`)
            accumulatedOutput += chunk
            console.log(`📝 [NODE_CHUNK] 累积后总长度: ${accumulatedOutput.length}`)

            // 🔧 完全参考RAG实现:使用splice替换对象（不使用$nextTick，避免批量合并）
            if (currentRuntimeUuid) {
              const index = this.localRuntimeList.findIndex(r => r.runtimeUuid === currentRuntimeUuid)
              console.log(`📝 [NODE_CHUNK] 查找runtime, index: ${index}, currentRuntimeUuid: ${currentRuntimeUuid}`)
              if (index !== -1) {
                const oldRuntime = this.localRuntimeList[index]
                const newRuntime = { ...oldRuntime, output: accumulatedOutput }
                this.localRuntimeList.splice(index, 1, newRuntime)

                console.log(`✅ [NODE_CHUNK] 已更新runtime.output, 当前output长度: ${accumulatedOutput.length}`)
              } else {
                console.warn(`⚠️ [NODE_CHUNK] 未找到对应的runtime, currentRuntimeUuid: ${currentRuntimeUuid}`)
              }
            } else {
              console.warn(`⚠️ [NODE_CHUNK] currentRuntimeUuid为空`)
            }
          }

          // 处理NODE_OUTPUT事件：节点执行完成，提取最终输出
          if (eventName && eventName.startsWith('[NODE_OUTPUT_')) {
            console.log(`📤 [NODE_OUTPUT] 收到事件, 当前累积长度: ${accumulatedOutput.length}`)
            if (chunk && currentRuntimeUuid) {
              try {
                const outputData = JSON.parse(chunk)
                const index = this.localRuntimeList.findIndex(r => r.runtimeUuid === currentRuntimeUuid)
                if (index !== -1) {
                  // 检查输出数据格式：{name:"output", content:{value:"xxx"}}
                  if (outputData.content && outputData.content.value) {
                    const nodeOutput = outputData.content.value
                    // 🔧 关键修复：如果已经累积了流式输出，保留累积内容；否则使用NODE_OUTPUT的完整内容
                    // 这样既支持流式LLM节点(有NODE_CHUNK)，也支持非流式节点(只有NODE_OUTPUT)
                    if (accumulatedOutput.length === 0) {
                      accumulatedOutput = nodeOutput
                      console.log(`📤 [NODE_OUTPUT] 无累积内容，使用NODE_OUTPUT: ${nodeOutput.length}字符`)
                    } else {
                      console.log(`📤 [NODE_OUTPUT] 保留累积内容: ${accumulatedOutput.length}字符 (忽略NODE_OUTPUT的${nodeOutput.length}字符)`)
                    }
                    const oldRuntime = this.localRuntimeList[index]
                    const newRuntime = { ...oldRuntime, output: accumulatedOutput }
                    this.localRuntimeList.splice(index, 1, newRuntime)
                  } else if (outputData.output) {
                  // 兼容旧格式：{output: "xxx"}
                    if (accumulatedOutput.length === 0) {
                      accumulatedOutput = outputData.output
                      console.log(`📤 [NODE_OUTPUT] 使用旧格式output: ${accumulatedOutput.length}字符`)
                    } else {
                      console.log(`📤 [NODE_OUTPUT] 保留累积内容(旧格式): ${accumulatedOutput.length}字符`)
                    }
                    const oldRuntime = this.localRuntimeList[index]
                    const newRuntime = { ...oldRuntime, output: accumulatedOutput }
                    this.localRuntimeList.splice(index, 1, newRuntime)
                  }
                }
              } catch (e) {
                console.warn('Failed to parse NODE_OUTPUT data:', e)
              }
            }
          }
        },

        // [DONE]事件回调：工作流执行完成
        doneCallback: (chunk) => {
          this.running = false
          this.currentController = null

          // 通知WorkflowRunDetail组件运行完成
          if (this.$refs.runDetailRef) {
            this.$refs.runDetailRef.runDone()
          }

          // 更新runtime状态为成功，保存最终输出（使用splice确保响应式）
          if (currentRuntimeUuid) {
            const index = this.localRuntimeList.findIndex(r => r.runtimeUuid === currentRuntimeUuid)
            if (index !== -1) {
              const oldRuntime = this.localRuntimeList[index]
              const newRuntime = {
                ...oldRuntime,
                status: 3, // 3-成功 (后端WORKFLOW_PROCESS_STATUS_SUCCESS)
                loading: false,
                output: oldRuntime.output || accumulatedOutput
              }
              this.localRuntimeList.splice(index, 1, newRuntime)
            }
          }

          this.$message.success('工作流执行完成')
        },

        // [ERROR]事件回调：工作流执行失败
        errorCallback: (error) => {
          this.running = false
          this.currentController = null

          console.error('运行工作流失败:', error)
          this.$message.error(error || '工作流执行失败')

          // 通知WorkflowRunDetail组件运行失败
          if (this.$refs.runDetailRef) {
            this.$refs.runDetailRef.runError()
          }
        }
      })
    },

    /**
     * 取消工作流执行
     */
    handleCancelRun () {
      if (this.currentController) {
        this.currentController.abort()
        this.currentController = null
        this.running = false
        this.$message.info('已取消工作流执行')
      }
    },

    handleDelete (runtimeUuid) {
      this.$confirm('确定要删除这条运行记录吗？输入与输出会一起删除。', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(async () => {
        try {
          await workflowRuntimeDelete(runtimeUuid)
          // 从本地列表删除
          this.localRuntimeList = this.localRuntimeList.filter(r => r.runtimeUuid !== runtimeUuid)
          this.$message.success('删除成功')
        } catch (error) {
          console.error('删除运行记录失败:', error)
          this.$message.error(error.message || '删除失败')
        }
      }).catch(() => {
        // 取消删除
      })
    },

    showExecutionDetail (runtime) {
      this.currentRuntimeDetail = runtime
      this.detailDialogVisible = true
      // TODO: 如果没有节点详情，从后端加载
    },

    formatTime (time) {
      if (!time) return ''
      const date = new Date(time)
      const now = new Date()
      const diff = now - date

      if (diff < 60000) {
        return '刚刚'
      } else if (diff < 3600000) {
        return `${Math.floor(diff / 60000)}分钟前`
      } else if (diff < 86400000) {
        return `${Math.floor(diff / 3600000)}小时前`
      } else {
        return date.toLocaleString('zh-CN')
      }
    },

    formatValue (value) {
      if (value === null || value === undefined) return ''
      // 处理工作流输入/输出的特殊格式：{type:1, value:"xxx", title:"xxx"}
      if (typeof value === 'object' && value.value !== undefined) {
        return this.formatValue(value.value) // 递归提取value字段
      }
      if (typeof value === 'object') {
        return JSON.stringify(value, null, 2)
      }
      return String(value)
    },

    getStatusType (status) {
      // 对齐后端WorkflowConstants状态定义
      const typeMap = {
        0: 'info', // READY-就绪
        1: 'info', // RUNNING-运行中
        2: 'warning', // WAITING_INPUT-等待输入
        3: 'success', // SUCCESS-成功
        4: 'danger' // FAIL-失败
      }
      return typeMap[status] || 'info'
    },

    getStatusText (status) {
      // 对齐后端WorkflowConstants状态定义
      const textMap = {
        0: '就绪',
        1: '运行中',
        2: '等待输入',
        3: '成功',
        4: '失败'
      }
      return textMap[status] || '未知'
    },

    getNodeStatusType (status) {
      const typeMap = {
        1: 'primary',
        2: 'success',
        3: 'warning',
        4: 'danger'
      }
      return typeMap[status] || 'info'
    },

    getNodeStatusIcon (status) {
      const iconMap = {
        1: 'el-icon-loading',
        2: 'el-icon-check',
        3: 'el-icon-warning',
        4: 'el-icon-close'
      }
      return iconMap[status] || 'el-icon-info'
    },

    /**
     * 动态计算main区域的高度
     * 公式：main高度 = 100% - footer高度
     */
    calculateMainHeight () {
      this.$nextTick(() => {
        const footerEl = this.$refs.footerContainer
        if (footerEl) {
          const footerHeight = footerEl.offsetHeight
          const totalFixedHeight = footerHeight + 100
          this.mainHeight = `calc(100% - ${totalFixedHeight}px)`
        }
      })
    }
  }
}
</script>

<style lang="scss" scoped>
.workflow-runtime-list {
  height: 100%;
  position: relative;
}

/* main: 动态计算高度 */
.runtime-scroll-container {
  overflow: hidden;
  background-color: #f5f7fa;
}

/* 内部真正滚动的容器 */
.runtime-scroll-inner {
  height: 100%;
  overflow-y: auto;
  padding: 16px;
}

.empty-state {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #909399;

  i {
    font-size: 64px;
    margin-bottom: 16px;
    opacity: 0.6;
  }

  p {
    font-size: 16px;
    margin: 8px 0;
  }

  .hint {
    font-size: 14px;
    color: #c0c4cc;
  }
}

.runtime-list {
  max-width: 100%;
  margin: 0 auto;
  width: 100%;
  padding: 0 20px;
}

.runtime-item {
  margin-bottom: 32px;
  width: 100%;
}

.message-row {
  display: flex;
  align-items: flex-end;
  gap: 12px;
  margin-bottom: 16px;

  &.user-message-row {
    flex-direction: row;
    justify-content: flex-end;
  }

  &.ai-message-row {
    flex-direction: row;
    justify-content: flex-start;
  }
}

.message-avatar {
  flex-shrink: 0;

  ::v-deep .el-avatar {
    background-color: #409eff;

    &.ai-avatar {
      background-color: #67c23a;
    }
  }
}

.message-wrapper {
  padding: 12px 16px;
  border-radius: 8px;
  max-width: 85%;
  word-wrap: break-word;
  line-height: 1.5;
  transition: all 0.3s ease;

  &.user-message {
    background: linear-gradient(to right, #5fa3f5, #4a9ff5);
    color: white;

    .message-label,
    .message-time,
    .input-label,
    .input-value {
      color: white;
    }

    .message-header {
      border-bottom-color: rgba(255, 255, 255, 0.2);
    }

    .delete-btn {
      color: white;
      &:hover {
        color: rgba(255, 255, 255, 0.8);
      }
    }

    .no-input {
      color: rgba(255, 255, 255, 0.7);
    }
  }

  &.ai-message {
    background-color: #ffffff;
    color: #303133;
    border: 1px solid #e4e7ed;
  }
}

.message-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
  padding-bottom: 12px;
  border-bottom: 1px solid #ebeef5;
}

.message-info {
  display: flex;
  align-items: center;
  gap: 8px;

  .message-label {
    font-weight: 500;
  }

  .message-time {
    font-size: 12px;
    color: #909399;
  }
}

.delete-btn {
  color: #f56c6c;

  &:hover {
    color: #f78989;
  }
}

.message-content {
  line-height: 1.6;
  color: #606266;
}

.input-content,
.output-object {
  .input-item,
  .output-item {
    margin-bottom: 8px;

    .input-label,
    .output-label {
      font-weight: 500;
      margin-right: 8px;
      color: #606266;
    }

    .input-value,
    .output-value {
      color: #303133;
      word-break: break-all;
    }
  }
}

.no-input,
.no-output {
  color: #c0c4cc;
  font-style: italic;
}

.loading-content,
.loading-placeholder {
  display: flex;
  align-items: center;
  gap: 8px;
  color: #409eff;

  i {
    font-size: 16px;
  }
}

.streaming-header {
  display: flex;
  align-items: center;
  gap: 8px;
  color: #409eff;
  margin-bottom: 12px;
  padding: 8px;
  background-color: #ecf5ff;
  border-radius: 4px;

  i {
    font-size: 16px;
    animation: rotating 1s linear infinite;
  }

  span {
    font-size: 14px;
    font-weight: 500;
  }
}

.output-text {
  white-space: pre-wrap;
  word-break: break-word;
}

.streaming-indicator {
  display: inline-flex;
  align-items: center;
  margin-left: 8px;
  color: #409eff;

  i {
    font-size: 14px;
    animation: rotating 1s linear infinite;
  }
}

@keyframes rotating {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.error-content {
  display: flex;
  align-items: center;
  gap: 8px;
  color: #f56c6c;

  i {
    font-size: 16px;
  }
}

.loading-more,
.loaded-all {
  text-align: center;
  padding: 16px;
  color: #909399;
  font-size: 14px;
}

.loading-more i {
  margin-right: 8px;
}

.runtime-footer {
  border-top: 1px solid #e4e7ed;
  background-color: #fff;
  padding: 16px;
}

.execution-detail {
  .detail-section {
    margin-bottom: 24px;

    h4 {
      margin: 0 0 12px 0;
      font-size: 16px;
      font-weight: 500;
      color: #303133;
    }
  }

  .node-detail {
    .node-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;

      .node-name {
        font-weight: 500;
        color: #303133;
      }
    }

    .node-output {
      margin-top: 8px;
      padding: 8px;
      background-color: #f5f7fa;
      border-radius: 4px;

      .output-label {
        font-weight: 500;
        color: #606266;
        margin-bottom: 4px;
      }

      .output-value {
        color: #303133;
        white-space: pre-wrap;
        word-break: break-word;
      }
    }

    .node-error {
      margin-top: 8px;
      padding: 8px;
      background-color: #fef0f0;
      border-radius: 4px;
      color: #f56c6c;
      display: flex;
      align-items: center;
      gap: 8px;

      i {
        font-size: 16px;
      }
    }
  }
}
</style>
